/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *      â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *      â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
 *       â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
 *       â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
 *      â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
 *      â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•  â•šâ•â•â•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•
 *
 *                              ðŸŒ MOTEUR XR / GÃ‰NÃ‰RATION D'ENVIRONNEMENTS ðŸŒ
 *                   SystÃ¨me complet de gÃ©nÃ©ration procÃ©durale d'environnements 3D
 *
 *   ARCHITECTURE:
 *   â”œâ”€â”€ XREnvironmentEngine      â†’ Moteur principal de gÃ©nÃ©ration
 *   â”œâ”€â”€ EnvironmentDirective     â†’ SystÃ¨me de directives de crÃ©ation
 *   â”œâ”€â”€ AgentPromptGenerator     â†’ GÃ©nÃ©ration de prompts par agents
 *   â”œâ”€â”€ SpatialAudioManager      â†’ Gestion audio spatiale
 *   â””â”€â”€ AvatarVoiceSystem        â†’ SystÃ¨me voix/avatar
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTES ET CONFIGURATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const FREQUENCY_MAPPINGS = {
  // Solfeggio Frequencies
  396: { chakra: 'root', color: '#FF0000', mood: 'liberation', element: 'earth' },
  417: { chakra: 'sacral', color: '#FF7F00', mood: 'change', element: 'water' },
  528: { chakra: 'solar', color: '#FFFF00', mood: 'transformation', element: 'fire' },
  639: { chakra: 'heart', color: '#00FF00', mood: 'connection', element: 'air' },
  741: { chakra: 'throat', color: '#0000FF', mood: 'expression', element: 'ether' },
  852: { chakra: 'third_eye', color: '#4B0082', mood: 'intuition', element: 'light' },
  963: { chakra: 'crown', color: '#8B00FF', mood: 'enlightenment', element: 'cosmic' },

  // ATÂ·OM Frequencies
  111: { essence: 'initiation', geometry: 'point' },
  222: { essence: 'duality', geometry: 'line' },
  333: { essence: 'trinity', geometry: 'triangle' },
  444: { essence: 'heartbeat', geometry: 'square' },
  555: { essence: 'change', geometry: 'pentagon' },
  666: { essence: 'matter', geometry: 'hexagon' },
  777: { essence: 'spirit', geometry: 'heptagon' },
  888: { essence: 'infinity', geometry: 'octagon' },
  999: { essence: 'completion', geometry: 'nonagon' }
};

export const ENVIRONMENT_TEMPLATES = {
  nexus: {
    name: 'Nexus Central',
    baseGeometry: 'torus',
    lighting: 'volumetric',
    particles: 'golden_dust',
    ambience: 'ethereal',
    objects: ['central_orb', 'floating_platforms', 'energy_streams']
  },
  sanctuaire: {
    name: 'Sanctuaire',
    baseGeometry: 'dome',
    lighting: 'soft_ambient',
    particles: 'light_motes',
    ambience: 'peaceful',
    objects: ['meditation_cushion', 'water_feature', 'sacred_symbols']
  },
  forge: {
    name: 'Forge CrÃ©ative',
    baseGeometry: 'industrial',
    lighting: 'dramatic',
    particles: 'sparks',
    ambience: 'energetic',
    objects: ['workbench', 'tools', 'creation_nodes']
  },
  bibliotheque: {
    name: 'BibliothÃ¨que Akashique',
    baseGeometry: 'infinite_library',
    lighting: 'mystical',
    particles: 'knowledge_wisps',
    ambience: 'contemplative',
    objects: ['floating_books', 'reading_alcoves', 'memory_crystals']
  },
  jardin: {
    name: 'Jardin Quantique',
    baseGeometry: 'organic',
    lighting: 'natural',
    particles: 'pollen',
    ambience: 'nurturing',
    objects: ['quantum_flowers', 'probability_trees', 'stream_of_consciousness']
  },
  observatoire: {
    name: 'Observatoire Cosmique',
    baseGeometry: 'sphere',
    lighting: 'starlight',
    particles: 'stardust',
    ambience: 'vast',
    objects: ['telescope', 'star_map', 'constellation_viewer']
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSE: DIRECTIVE D'ENVIRONNEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class EnvironmentDirective {
  constructor(options = {}) {
    this.id = options.id || `env_${Date.now()}`;
    this.name = options.name || 'Nouvel Environnement';
    this.type = options.type || 'custom';
    this.frequency = options.frequency || 444;
    this.mood = options.mood || 'neutral';
    this.colorPalette = options.colorPalette || ['#D4AF37', '#1A1A2E', '#FFFFFF'];
    this.objects = options.objects || [];
    this.lighting = options.lighting || 'ambient';
    this.audio = options.audio || null;
    this.interactions = options.interactions || [];
    this.createdAt = new Date().toISOString();
  }

  toPrompt() {
    return `
GÃ©nÃ¨re un environnement 3D immersif avec les caractÃ©ristiques suivantes:
- Nom: ${this.name}
- Type: ${this.type}
- FrÃ©quence vibratoire: ${this.frequency} Hz
- Ambiance: ${this.mood}
- Palette de couleurs: ${this.colorPalette.join(', ')}
- Ã‰clairage: ${this.lighting}
- Objets Ã  inclure: ${this.objects.join(', ')}

L'environnement doit respecter les principes de gÃ©omÃ©trie sacrÃ©e et crÃ©er une atmosphÃ¨re propice Ã  ${this.mood}.
La frÃ©quence ${this.frequency} Hz influence les particules et les animations de l'environnement.
    `.trim();
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      frequency: this.frequency,
      mood: this.mood,
      colorPalette: this.colorPalette,
      objects: this.objects,
      lighting: this.lighting,
      audio: this.audio,
      interactions: this.interactions,
      createdAt: this.createdAt
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSE: GÃ‰NÃ‰RATEUR DE PROMPTS AGENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class AgentPromptGenerator {
  constructor() {
    this.templates = {
      environment: this.environmentTemplate,
      dialogue: this.dialogueTemplate,
      analysis: this.analysisTemplate,
      creation: this.creationTemplate,
      voice: this.voiceTemplate
    };
  }

  environmentTemplate(directive) {
    const freqData = FREQUENCY_MAPPINGS[directive.frequency] || {};
    return {
      system: `Tu es un agent spÃ©cialisÃ© dans la gÃ©nÃ©ration d'environnements XR immersifs.
Tu utilises la gÃ©omÃ©trie sacrÃ©e et les frÃ©quences vibratoires pour crÃ©er des espaces harmonieux.
FrÃ©quence actuelle: ${directive.frequency} Hz
Chakra associÃ©: ${freqData.chakra || 'non dÃ©fini'}
Ã‰lÃ©ment: ${freqData.element || 'universel'}`,

      user: directive.toPrompt(),

      parameters: {
        temperature: 0.7,
        max_tokens: 2000,
        frequency_penalty: 0.3
      }
    };
  }

  dialogueTemplate(agent, context) {
    return {
      system: `Tu es ${agent.name}, un agent de niveau ${agent.level}.
PersonnalitÃ©: ${agent.personality || 'professionnel et bienveillant'}
SpÃ©cialisation: ${agent.specialty || 'assistance gÃ©nÃ©rale'}
Ton: ${agent.tone || 'chaleureux'}

Tu communiques de maniÃ¨re claire et empathique.
Tu utilises les principes de rÃ©sonance et d'harmonie dans tes rÃ©ponses.`,

      user: context.query,

      parameters: {
        temperature: 0.8,
        max_tokens: 1000
      }
    };
  }

  analysisTemplate(data, analysisType) {
    return {
      system: `Tu es un agent d'analyse spÃ©cialisÃ© dans l'interprÃ©tation des donnÃ©es selon les principes CHEÂ·NU.
Type d'analyse: ${analysisType}
Tu combines analyse quantitative et qualitative avec une perspective holistique.`,

      user: `Analyse les donnÃ©es suivantes:
${JSON.stringify(data, null, 2)}

Fournis une analyse dÃ©taillÃ©e incluant:
1. Patterns observÃ©s
2. CorrÃ©lations avec les frÃ©quences
3. Recommandations d'harmonisation`,

      parameters: {
        temperature: 0.5,
        max_tokens: 1500
      }
    };
  }

  creationTemplate(creationType, specifications) {
    return {
      system: `Tu es un agent crÃ©atif spÃ©cialisÃ© dans la gÃ©nÃ©ration de ${creationType}.
Tu respectes les vÃ©ritÃ©s canoniques CHEÂ·NU.
Tu intÃ¨gres les principes de gÃ©omÃ©trie sacrÃ©e et de rÃ©sonance.`,

      user: `CrÃ©e ${creationType} avec les spÃ©cifications suivantes:
${JSON.stringify(specifications, null, 2)}`,

      parameters: {
        temperature: 0.9,
        max_tokens: 2500
      }
    };
  }

  voiceTemplate(voiceProfile, text) {
    return {
      system: `Configuration de synthÃ¨se vocale pour le profil "${voiceProfile.name}":
- Genre: ${voiceProfile.gender}
- Ton: ${voiceProfile.tone}
- Pitch: ${voiceProfile.pitch}
- Vitesse: ${voiceProfile.speed || 1.0}

Adapte la prononciation et l'intonation au profil.`,

      text: text,

      parameters: {
        voice_id: voiceProfile.id,
        pitch: voiceProfile.pitch,
        rate: voiceProfile.speed || 1.0,
        volume: 1.0
      }
    };
  }

  generate(type, ...args) {
    const template = this.templates[type];
    if (!template) {
      throw new Error(`Template type "${type}" not found`);
    }
    return template.call(this, ...args);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSE: GESTIONNAIRE AUDIO SPATIAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class SpatialAudioManager {
  constructor() {
    this.audioContext = null;
    this.listener = null;
    this.sources = new Map();
    this.frequencies = new Map();
    this.isInitialized = false;
  }

  async initialize() {
    if (this.isInitialized) return;

    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.listener = this.audioContext.listener;
      this.isInitialized = true;
      console.log('SpatialAudioManager initialized');
    } catch (error) {
      console.error('Failed to initialize audio context:', error);
    }
  }

  setListenerPosition(x, y, z) {
    if (!this.isInitialized) return;

    if (this.listener.positionX) {
      this.listener.positionX.setValueAtTime(x, this.audioContext.currentTime);
      this.listener.positionY.setValueAtTime(y, this.audioContext.currentTime);
      this.listener.positionZ.setValueAtTime(z, this.audioContext.currentTime);
    } else {
      this.listener.setPosition(x, y, z);
    }
  }

  createFrequencyTone(frequency, position = { x: 0, y: 0, z: 0 }) {
    if (!this.isInitialized) return null;

    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    const panner = this.audioContext.createPanner();

    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
    oscillator.type = 'sine';

    panner.panningModel = 'HRTF';
    panner.distanceModel = 'inverse';
    panner.refDistance = 1;
    panner.maxDistance = 10000;
    panner.rolloffFactor = 1;
    panner.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
    panner.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
    panner.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);

    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);

    oscillator.connect(gainNode);
    gainNode.connect(panner);
    panner.connect(this.audioContext.destination);

    const id = `freq_${frequency}_${Date.now()}`;
    this.frequencies.set(id, { oscillator, gainNode, panner });

    return id;
  }

  playFrequency(id) {
    const freq = this.frequencies.get(id);
    if (freq) {
      freq.oscillator.start();
    }
  }

  stopFrequency(id) {
    const freq = this.frequencies.get(id);
    if (freq) {
      freq.oscillator.stop();
      this.frequencies.delete(id);
    }
  }

  async loadSpatialAudio(url, position = { x: 0, y: 0, z: 0 }) {
    if (!this.isInitialized) await this.initialize();

    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

      const source = this.audioContext.createBufferSource();
      const panner = this.audioContext.createPanner();
      const gainNode = this.audioContext.createGain();

      source.buffer = audioBuffer;
      panner.panningModel = 'HRTF';
      panner.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
      panner.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
      panner.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);

      source.connect(gainNode);
      gainNode.connect(panner);
      panner.connect(this.audioContext.destination);

      const id = `audio_${Date.now()}`;
      this.sources.set(id, { source, panner, gainNode });

      return id;
    } catch (error) {
      console.error('Failed to load spatial audio:', error);
      return null;
    }
  }

  dispose() {
    this.sources.forEach(({ source }) => {
      try { source.stop(); } catch (e) {}
    });
    this.frequencies.forEach((_, id) => this.stopFrequency(id));

    if (this.audioContext) {
      this.audioContext.close();
    }

    this.sources.clear();
    this.frequencies.clear();
    this.isInitialized = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSE: SYSTÃˆME VOIX/AVATAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class AvatarVoiceSystem {
  constructor() {
    this.synth = window.speechSynthesis;
    this.voices = [];
    this.currentVoice = null;
    this.isInitialized = false;
    this.avatarState = {
      expression: 'neutral',
      lipSync: false,
      gesture: 'idle'
    };
  }

  async initialize() {
    return new Promise((resolve) => {
      const loadVoices = () => {
        this.voices = this.synth.getVoices();
        this.isInitialized = true;
        resolve(this.voices);
      };

      if (this.synth.onvoiceschanged !== undefined) {
        this.synth.onvoiceschanged = loadVoices;
      }
      loadVoices();
    });
  }

  getAvailableVoices() {
    return this.voices.map(v => ({
      name: v.name,
      lang: v.lang,
      default: v.default
    }));
  }

  setVoice(voiceName) {
    const voice = this.voices.find(v => v.name === voiceName);
    if (voice) {
      this.currentVoice = voice;
      return true;
    }
    return false;
  }

  speak(text, options = {}) {
    return new Promise((resolve, reject) => {
      if (!this.synth) {
        reject(new Error('Speech synthesis not supported'));
        return;
      }

      // Cancel any ongoing speech
      this.synth.cancel();

      const utterance = new SpeechSynthesisUtterance(text);

      if (this.currentVoice) {
        utterance.voice = this.currentVoice;
      }

      utterance.pitch = options.pitch || 1.0;
      utterance.rate = options.rate || 1.0;
      utterance.volume = options.volume || 1.0;
      utterance.lang = options.lang || 'fr-FR';

      // Avatar lip sync events
      utterance.onstart = () => {
        this.avatarState.lipSync = true;
        this.avatarState.expression = 'speaking';
        if (options.onStart) options.onStart();
      };

      utterance.onend = () => {
        this.avatarState.lipSync = false;
        this.avatarState.expression = 'neutral';
        if (options.onEnd) options.onEnd();
        resolve();
      };

      utterance.onerror = (event) => {
        this.avatarState.lipSync = false;
        this.avatarState.expression = 'neutral';
        reject(event);
      };

      // Boundary events for word-by-word lip sync
      utterance.onboundary = (event) => {
        if (options.onBoundary) {
          options.onBoundary(event);
        }
      };

      this.synth.speak(utterance);
    });
  }

  stop() {
    if (this.synth) {
      this.synth.cancel();
      this.avatarState.lipSync = false;
      this.avatarState.expression = 'neutral';
    }
  }

  setAvatarExpression(expression) {
    const validExpressions = ['neutral', 'happy', 'sad', 'surprised', 'thinking', 'speaking'];
    if (validExpressions.includes(expression)) {
      this.avatarState.expression = expression;
      return true;
    }
    return false;
  }

  setAvatarGesture(gesture) {
    const validGestures = ['idle', 'wave', 'point', 'nod', 'shake', 'think'];
    if (validGestures.includes(gesture)) {
      this.avatarState.gesture = gesture;
      return true;
    }
    return false;
  }

  getAvatarState() {
    return { ...this.avatarState };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLASSE: MOTEUR XR PRINCIPAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class XREnvironmentEngine {
  constructor() {
    this.environments = new Map();
    this.activeEnvironment = null;
    this.promptGenerator = new AgentPromptGenerator();
    this.spatialAudio = new SpatialAudioManager();
    this.avatarVoice = new AvatarVoiceSystem();
    this.agents = new Map();
    this.isXRSupported = false;
    this.xrSession = null;
  }

  async initialize() {
    // Check XR support
    if ('xr' in navigator) {
      this.isXRSupported = await navigator.xr.isSessionSupported('immersive-vr');
    }

    // Initialize subsystems
    await this.spatialAudio.initialize();
    await this.avatarVoice.initialize();

    console.log('XREnvironmentEngine initialized', {
      xrSupported: this.isXRSupported
    });

    return {
      xrSupported: this.isXRSupported,
      audioInitialized: this.spatialAudio.isInitialized,
      voiceInitialized: this.avatarVoice.isInitialized
    };
  }

  // Agent Registration
  registerAgent(agent) {
    this.agents.set(agent.id, {
      ...agent,
      registeredAt: new Date().toISOString()
    });
    return agent.id;
  }

  getAgent(agentId) {
    return this.agents.get(agentId);
  }

  // Environment Generation
  async generateEnvironment(directive) {
    if (!(directive instanceof EnvironmentDirective)) {
      directive = new EnvironmentDirective(directive);
    }

    // Generate prompt for environment creation
    const prompt = this.promptGenerator.generate('environment', directive);

    // Store environment
    const environment = {
      id: directive.id,
      directive: directive.toJSON(),
      prompt: prompt,
      status: 'generating',
      createdAt: new Date().toISOString()
    };

    this.environments.set(directive.id, environment);

    // Simulate generation process
    await this.simulateGeneration(directive.id);

    // Update status
    environment.status = 'ready';
    environment.generatedAt = new Date().toISOString();

    return environment;
  }

  async simulateGeneration(envId) {
    // Simulate async generation process
    return new Promise(resolve => {
      setTimeout(() => {
        const env = this.environments.get(envId);
        if (env) {
          env.assets = {
            geometry: `geometry_${envId}.glb`,
            textures: [`texture_${envId}_diffuse.jpg`, `texture_${envId}_normal.jpg`],
            audio: `ambient_${envId}.mp3`
          };
        }
        resolve();
      }, 2000);
    });
  }

  async activateEnvironment(envId) {
    const environment = this.environments.get(envId);
    if (!environment) {
      throw new Error(`Environment ${envId} not found`);
    }

    if (environment.status !== 'ready') {
      throw new Error(`Environment ${envId} is not ready`);
    }

    // Deactivate current environment
    if (this.activeEnvironment) {
      await this.deactivateEnvironment();
    }

    this.activeEnvironment = envId;

    // Setup spatial audio based on frequency
    const directive = environment.directive;
    if (directive.frequency) {
      this.spatialAudio.createFrequencyTone(directive.frequency, { x: 0, y: 2, z: 0 });
    }

    return environment;
  }

  async deactivateEnvironment() {
    if (this.activeEnvironment) {
      this.spatialAudio.dispose();
      this.activeEnvironment = null;
    }
  }

  // XR Session Management
  async startXRSession(mode = 'immersive-vr') {
    if (!this.isXRSupported) {
      throw new Error('XR not supported on this device');
    }

    try {
      this.xrSession = await navigator.xr.requestSession(mode, {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['hand-tracking', 'bounded-floor']
      });

      this.xrSession.addEventListener('end', () => {
        this.xrSession = null;
      });

      return this.xrSession;
    } catch (error) {
      console.error('Failed to start XR session:', error);
      throw error;
    }
  }

  endXRSession() {
    if (this.xrSession) {
      this.xrSession.end();
    }
  }

  // Agent Communication
  async sendToAgent(agentId, message) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent ${agentId} not found`);
    }

    const prompt = this.promptGenerator.generate('dialogue', agent, { query: message });

    // Here you would send to actual LLM API
    // For now, return simulated response
    return {
      agentId,
      prompt,
      response: `[${agent.name}]: RÃ©ponse simulÃ©e pour "${message}"`,
      timestamp: new Date().toISOString()
    };
  }

  // Voice Synthesis
  async speakAs(agentId, text, options = {}) {
    const agent = this.agents.get(agentId);
    if (!agent) {
      throw new Error(`Agent ${agentId} not found`);
    }

    const voiceOptions = {
      ...options,
      pitch: agent.voicePitch || 1.0,
      rate: agent.voiceRate || 1.0
    };

    return this.avatarVoice.speak(text, voiceOptions);
  }

  // Get Status
  getStatus() {
    return {
      initialized: true,
      xrSupported: this.isXRSupported,
      xrSessionActive: !!this.xrSession,
      activeEnvironment: this.activeEnvironment,
      environmentCount: this.environments.size,
      agentCount: this.agents.size,
      audioEnabled: this.spatialAudio.isInitialized,
      voiceEnabled: this.avatarVoice.isInitialized
    };
  }

  // Cleanup
  dispose() {
    this.endXRSession();
    this.deactivateEnvironment();
    this.spatialAudio.dispose();
    this.avatarVoice.stop();
    this.environments.clear();
    this.agents.clear();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SINGLETON INSTANCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let engineInstance = null;

export const getXREngine = () => {
  if (!engineInstance) {
    engineInstance = new XREnvironmentEngine();
  }
  return engineInstance;
};

export default XREnvironmentEngine;
